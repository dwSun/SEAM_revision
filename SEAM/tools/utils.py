import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from ..settings import *


def get_adj_matters(key_matters, matter_list):
    key_matters = np.array(key_matters).astype("float")
    matter_list = np.array(matter_list).astype("float")
    adjested_key_matters = []
    for k in key_matters:
        m_diff = np.abs(matter_list - k)
        min_diff_idx = np.argmin(m_diff)
        min_diff_m = matter_list[min_diff_idx]
        adjested_key_matters.append(min_diff_m)
    adjested_key_matters = np.array(adjested_key_matters)
    return adjested_key_matters


def add_subcls(a_cls_sub, ec_cls, to_replace_cls):
    a_cls_sub_int = a_cls_sub.astype("int")
    a_cls_sub_int[a_cls_sub_int == int(to_replace_cls)] = -1
    a_cls_sub_int[a_cls_sub_int > int(to_replace_cls)] -= 1
    a_cls_sub_int_max = a_cls_sub_int.max()

    ec_cls_int = ec_cls.astype("int")
    ec_cls_int -= ec_cls_int.min()
    ec_cls_int += a_cls_sub_int_max + 1
    a_cls_sub_int[a_cls_sub_int == -1] = ec_cls_int
    return a_cls_sub_int.astype("str")


def ind2ij(ind, size, axis):
    i, j = divmod(ind - 1, size)
    i += 1
    j += 1
    return np.array([i, j])[axis]


def get_labeling(label, cell_idx, cell_pos):
    #     y是cell-rela的细胞对应的标签
    #     print('pred_y',np.unique(label))
    labeling = np.zeros(shape=(IMG_SZ1 * IMG_SZ2, 1))
    b = cell_idx.copy()
    num_cells = label.shape[0]
    for i in range(num_cells):
        b[b == i + 1] = label[i] + 1
    #     print(cell_pos)
    #     print('b',np.unique(b))
    #     cell_pos = cell_pos.astype('int')
    labeling[cell_pos.astype("int") - 1, 0] = b

    return labeling


def plot_label_image(a, pred_y, cmp, save=None, mask=None, figsize=(5, 5), anno=False, ifshow=True, return_mat=False):

    cell_idx = a.uns["cell_idx"]
    cell_pos = a.uns["cell_pos"]

    to_labeling_pred_y = np.array(pred_y.astype("int"))
    to_labeling_pred_y_min = to_labeling_pred_y.min()
    # to_labeling_pred_y[coc[448,:]>0]=3
    # to_labeling_pred_y = resultsLWEA[:,2]
    # to_labeling_pred_y = label_list_FF[2]
    # to_labeling_pred_y = label_list[3]
    # to_labeling_pred_y[mark_list]=2
    #     cluster_cmp = sns.hls_palette(np.unique(to_labeling_pred_y).shape[0])
    unique_cls = np.unique(pred_y).shape[0]
    #     unique_cls_mask = [unique_cls[m] for m in mask]
    cluster_cmp = cmp.copy()

    if mask is not None:
        for to_mask in range(unique_cls):
            if to_mask in mask:
                continue
            cluster_cmp[to_mask] = "k"
    labeling_plot_cmp = ["k"]
    labeling_plot_cmp.extend(cluster_cmp)
    labeling = get_labeling(to_labeling_pred_y - np.min(to_labeling_pred_y), cell_idx, cell_pos)
    # labeling[labeling==5]=0
    img1 = labeling.reshape((IMG_SZ1, IMG_SZ2))
    plt.figure(figsize=figsize)
    # plt.imshow(img1)
    ticks = np.arange(np.min(img1) + 1, np.max(img1) + 1)
    boundaries = np.arange(np.min(img1) + 0.5, np.max(img1) + 1.5)
    #     with sns.plotting_context(font_scale=font_scale):
    sns.heatmap(
        img1,
        cmap=labeling_plot_cmp,
        linewidths=0,
        linecolor="k",
        square=True,
        cbar_kws={"ticks": ticks, "boundaries": boundaries, "fraction": 0.046, "pad": 0.04},
    )
    # sns.heatmap(img1,cmap=labeling_plot_cmp,square=True,ad':0.04})
    #     plt.legend(fontsize=font_size)
    plt.xticks([])
    plt.yticks([])
    if save is not None:
        plt.savefig(save, transparent=False, format="png", bbox_inches="tight")

    if anno:
        num_cells = pred_y.shape[0]
        for i in range(num_cells):
            cur_idx = i + 1
            cur_ind = cell_pos[cell_idx == cur_idx][0]
            #     print(ind2ij(cur_ind,256,0))
            #     print(ind2ij(cur_ind,256,1))
            if to_labeling_pred_y[i] - to_labeling_pred_y_min in mask:
                plt.annotate(str(cur_idx - 1), (ind2ij(cur_ind, IMG_SZ1, 1), ind2ij(cur_ind, IMG_SZ1, 0)), color="red")

    if ifshow:
        plt.show()
    if return_mat:
        return img1
